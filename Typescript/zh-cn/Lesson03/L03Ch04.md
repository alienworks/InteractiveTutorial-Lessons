---
title: "事件与判断"
actions: ['checkAnswer', 'hints']
material: 
  editor:
    language: typescript
    startingCode: |
        import {
            SmartContract,
            SerializableValueObject,
            MapStorage,
            constant,
            Blockchain,
            createEventNotifier,
            Address,
            Deploy
        } from '@neo-one/smart-contract';

        interface Alien extends SerializableValueObject {
            xna: number;
            readonly alienName: string;
            readonly blockHeight: number;
            readonly id: number;
        }

        const notifyCreation = createEventNotifier<number>(
            'generate',
            'id'
        );

        const notifyReward = createEventNotifier<string, number>(
            'reward',
            'attribute',
            'value'
        );

        const notifyPunishment = createEventNotifier<string, number>(
            'punish',
            'attribute',
            'value'
        );

        export class AlienFinder extends SmartContract {

            private readonly aliens = MapStorage.for<number, Alien>();

            private counter: number = 0; 

            public constructor(public readonly owner: Address = Deploy.senderAddress) {
                super();
            }

            public generateAlien(alienName: string) {
                if (!Address.isCaller(this.owner)) {
                    throw new Error('Expected caller to be the owner');
                }

                let blockHeight: number = Blockchain.currentHeight;
                let xna: number = this.findXna(this.randomNumber(blockHeight));
                let id: number = ++this.counter;
                let someAlien: Alien = {xna: xna, alienName: alienName, blockHeight: blockHeight, id: id};
                this.aliens.set(id, someAlien);
                notifyCreation(someAlien.id);
            }

            @constant
            private randomNumber(blockHeight: number): number {
                return Blockchain.currentBlockTime * blockHeight;
            }

            @constant
            private findXna(randomNumber: number): number {
                return randomNumber % 1E8;
            }

            @constant
            public query(id: number): Alien {
                const alien = this.aliens.get(id);
                if (alien === undefined) {
                    throw new Error('Alien not found');
                }
                else {
                    return alien;
                }
            }

            public mutate(id: number, attribute: number) {
                let a: Alien = this.query(id);
                let blockHeight: number = Blockchain.currentHeight;
                let randomDigit: number = this.randomNumber(blockHeight) % 100;

                switch(attribute) {
                    case 0: {
                        let right: number = a.xna % 1E6;
                        a.xna = randomDigit * 1E6 + right;
                        this.aliens.set(id, a);
                        break;
                    }
                    case 1: {
                        let left: number = a.xna / 1E6;
                        let right: number = a.xna % 1E4;
                        a.xna = left * 1E6 + randomDigit * 1E4 + right;
                        this.aliens.set(id, a);
                        break;
                    }
                    case 2: {
                        let left: number = a.xna / 1E4;
                        let right: number = a.xna % 1E2;
                        a.xna = left * 1E4 + randomDigit * 1E2 + right;
                        this.aliens.set(id, a);
                        break;
                    }
                    case 3: {
                        let left: number = a.xna / 1E2;
                        a.xna = left * 1E2 + randomDigit;
                        this.aliens.set(id, a);
                        break;
                    }
                    default: {
                        break;
                    }
                }
            }

            @constant
            public d6(): number {
                return this.randomNumber(Blockchain.currentHeight) % 6;
            }

            @constant
            public d10(): number {
                return this.randomNumber(Blockchain.currentHeight) % 10;
            }

            @constant
            public d100(): number {
                return this.randomNumber(Blockchain.currentHeight) % 100;
            }

            @constant
            public dN(n: number): number {
                return this.randomNumber(Blockchain.currentHeight) % n + 1;
            }

            private reward(alien: Alien) {
                let attribute: number = this.d6() / 2;
                let value: number = this.d10();

                switch(attribute) {
                    case 0: {
                        alien.xna += value * 1E4;
                        notifyReward('strength', value);
                        this.aliens.set(alien.id, alien);
                        break;
                    }
                    case 1: {
                        alien.xna += value * 1E2;
                        notifyReward('speed', value);
                        this.aliens.set(alien.id, alien);
                        break;
                    }
                    case 2: {
                        alien.xna += value;
                        notifyReward('weight', value);
                        this.aliens.set(alien.id, alien);
                        break;
                    }
                    default: {
                        break;
                    }
                }
            }

            private punish(alien: Alien) {
                let attribute: number = this.d6() / 2;
                let value: number = this.d10();

                switch(attribute) {
                    case 0: {
                        alien.xna -= this.d10() * 1E4;
                        notifyPunishment('strength', value);
                        this.aliens.set(alien.id, alien);
                        break;
                    }
                    case 1: {
                        alien.xna -= this.d10() * 1E2;
                        notifyPunishment('speed', value);
                        this.aliens.set(alien.id, alien);
                        break;
                    }
                    case 2: {
                        alien.xna -= this.d10();
                        notifyPunishment('weight', value);
                        this.aliens.set(alien.id, alien);
                        break;
                    }
                    default: {
                        break;
                    }
                }
            }

            // Add the new method here
        }
    answer: > 
        import {
            SmartContract,
            SerializableValueObject,
            MapStorage,
            constant,
            Blockchain,
            createEventNotifier,
            Address,
            Deploy
        } from '@neo-one/smart-contract';

        interface Alien extends SerializableValueObject {
            xna: number;
            readonly alienName: string;
            readonly blockHeight: number;
            readonly id: number;
        }

        const notifyCreation = createEventNotifier<number>(
            'generate',
            'id'
        );

        const notifyReward = createEventNotifier<string, number>(
            'reward',
            'attribute',
            'value'
        );

        const notifyPunishment = createEventNotifier<string, number>(
            'punish',
            'attribute',
            'value'
        );

        export class AlienFinder extends SmartContract {

            private readonly aliens = MapStorage.for<number, Alien>();

            private counter: number = 0; 

            public constructor(public readonly owner: Address = Deploy.senderAddress) {
                super();
            }

            public generateAlien(alienName: string) {
                if (!Address.isCaller(this.owner)) {
                    throw new Error('Expected caller to be the owner');
                }

                let blockHeight: number = Blockchain.currentHeight;
                let xna: number = this.findXna(this.randomNumber(blockHeight));
                let id: number = ++this.counter;
                let someAlien: Alien = {xna: xna, alienName: alienName, blockHeight: blockHeight, id: id};
                this.aliens.set(id, someAlien);
                notifyCreation(someAlien.id);
            }

            @constant
            private randomNumber(blockHeight: number): number {
                return Blockchain.currentBlockTime * blockHeight;
            }

            @constant
            private findXna(randomNumber: number): number {
                return randomNumber % 1E8;
            }

            @constant
            public query(id: number): Alien {
                const alien = this.aliens.get(id);
                if (alien === undefined) {
                    throw new Error('Alien not found');
                }
                else {
                    return alien;
                }
            }

            public mutate(id: number, attribute: number) {
                let a: Alien = this.query(id);
                let blockHeight: number = Blockchain.currentHeight;
                let randomDigit: number = this.randomNumber(blockHeight) % 100;

                switch(attribute) {
                    case 0: {
                        let right: number = a.xna % 1E6;
                        a.xna = randomDigit * 1E6 + right;
                        this.aliens.set(id, a);
                        break;
                    }
                    case 1: {
                        let left: number = a.xna / 1E6;
                        let right: number = a.xna % 1E4;
                        a.xna = left * 1E6 + randomDigit * 1E4 + right;
                        this.aliens.set(id, a);
                        break;
                    }
                    case 2: {
                        let left: number = a.xna / 1E4;
                        let right: number = a.xna % 1E2;
                        a.xna = left * 1E4 + randomDigit * 1E2 + right;
                        this.aliens.set(id, a);
                        break;
                    }
                    case 3: {
                        let left: number = a.xna / 1E2;
                        a.xna = left * 1E2 + randomDigit;
                        this.aliens.set(id, a);
                        break;
                    }
                    default: {
                        break;
                    }
                }
            }

            @constant
            public d6(): number {
                return this.randomNumber(Blockchain.currentHeight) % 6;
            }

            @constant
            public d10(): number {
                return this.randomNumber(Blockchain.currentHeight) % 10;
            }

            @constant
            public d100(): number {
                return this.randomNumber(Blockchain.currentHeight) % 100;
            }

            @constant
            public dN(n: number): number {
                return this.randomNumber(Blockchain.currentHeight) % n + 1;
            }

            private reward(alien: Alien) {
                let attribute: number = this.d6() / 2;
                let value: number = this.d10();

                switch(attribute) {
                    case 0: {
                        alien.xna += value * 1E4;
                        notifyReward('strength', value);
                        this.aliens.set(alien.id, alien);
                        break;
                    }
                    case 1: {
                        alien.xna += value * 1E2;
                        notifyReward('speed', value);
                        this.aliens.set(alien.id, alien);
                        break;
                    }
                    case 2: {
                        alien.xna += value;
                        notifyReward('weight', value);
                        this.aliens.set(alien.id, alien);
                        break;
                    }
                    default: {
                        break;
                    }
                }
            }

            private punish(alien: Alien) {
                let attribute: number = this.d6() / 2;
                let value: number = this.d10();

                switch(attribute) {
                    case 0: {
                        alien.xna -= this.d10() * 1E4;
                        notifyPunishment('strength', value);
                        this.aliens.set(alien.id, alien);
                        break;
                    }
                    case 1: {
                        alien.xna -= this.d10() * 1E2;
                        notifyPunishment('speed', value);
                        this.aliens.set(alien.id, alien);
                        break;
                    }
                    case 2: {
                        alien.xna -= this.d10();
                        notifyPunishment('weight', value);
                        this.aliens.set(alien.id, alien);
                        break;
                    }
                    default: {
                        break;
                    }
                }
            }

            private judge(alien: Alien, value: number) {
                if (value + this.d100() > 100) {
                    this.reward(alien);
                }
                else {
                    this.punish(alien);
                }
            }
        }
---

# 事件与判断

在上一章中，我们定义了两个基本规则——奖励和惩罚。 现在是时候定义更多内容并构建故事了。

当外星人出去探索世界时，他们将经过很多地方。 例如，一条被石头阻塞的道路，被汽油污染的区域和一座可能倒塌的桥梁。 我们需要定义一些规则，以便可以知道会发生什么。

为了使游戏合理即充满挑战，有两个原则：
- 事件结果应基于Alien的属性之一。
- 事件需要一定的随机性，可使结果不可预测。

D100在这里很有帮助，它意识到了事件的可能性。 由于Alien的所有这些属性值都在 `0` 到 `99`之间,因此我们可以将它们视为某种可能性，并将事件的合格线设置为`100`。

例如，当外星人试图通过弱小的桥梁时，其重量决定了桥梁是否会断裂。 在代码中，我们将确认，

```typescript
if (weight + this.d100() > 100)
```

如果重量值为 `60`，则安全过桥的可能性为40％，即 D100给出不大于 `40` 的数字的可能性仅为40％。 因此，如果D100给出的数字不大于 `40` ，那么`weight + this.d100() > 100` 的结果将为假，这意味着桥梁不会断裂。

## 指令

- 添加一个名为`judge`的新方法。 它以当前的 `alien`和数值 `value` 作为输入。
- 在这个方法中，用 `d100()`实现判断逻辑。
- 如果结果过了 `100`,则调用方法 `reward()` ，否则调用 `punish()`方法。
